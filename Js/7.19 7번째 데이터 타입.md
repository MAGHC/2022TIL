심벌이란?
심벌은 es6에서 도입된 7번째 데이터 타입으로 변경 불가능한 원시타입의 값이다. 심벌 값은 다른값과 중복되지 않는 유일무이한 값이다. 따라서 주로 이름의 충돌 위험이 없는 유일한 프로퍼티 키를 만들기 위해 사용한다.

10.3절 "프로퍼티"에서 살펴본 바와 같이 프로퍼티 키로 사용할 수 있는 값은 빈 문자열을 포함하는 모든 문자열 또는 심벌값이다.

심벌 값의 생성

Symbol 함수
다른값과 절대 중복되지않는 유일무이한 값이다.

Const mySymbol = symbol();//symbol

선택적으로 문자열을 인수로 전달 할 ㅅ n있다.

이 문자열은 생성된 심벌값에 대한 설명으로 디버깅 용도로만 사용되며 심벌값생성에 어떠한 영향도 주지않는다.

심벌값도 문자열, 숫자 , 불리언 과 같이 객체처럼 접근하면 암묵적으로 래퍼 객체를 생성한다.

심벌 값은 암묵적으로 문자열이나 숫자타입으로 반환되지않는다.

불리언 타입으로는 암묵적으로 타입 변환이 된다. If문등에서 존재확인가능

Symbol.for / .keyfor 메서드

Symbol.for 메서드는 인수로 전달받은 문자열을 키로 사용하여 키와 심벌값의 쌍들이 저장되어있는

심벌 레지스트리 에 해당 키와 일치하는 심벌 값을 검색한다.

    - 검색에 성공하면 새로운 심벌값을 생성하지 않고 검색된 심벌 값을 반환한다.
    - 검색에 실패하면 새로운 심벌값을 생성하여 symbol.for 메서드의 인수로 전달된 키로 전역 심벌 레지스트리에 저장한 후, 생성된 심벌 값을 반환한다

Const s1 = Symbol.for('mySymbol' ) 마이심볼이라는 심벌이없으면 새로 생성

해당값이있으면 해당 심벌값을 반환

Keyfor 메서드를 사용하여 저장된 심벌값의 키를 추출

Symbol.keyfor(s1) // mySymbol

Symbol for는 전역 심벌 레지스트리에 저장하는데 그냥 symbol()은 아닌듯

심벌과 상수

4방향을 예를 들어 정의한다면

Const Direction = {
UP:1,
Down:2,
Left:3,
Right:4
}

Up:symbol('up') ...반복

가능 중복될 일없이 정의
1,2,3,4 같은건 다른거랑 중복될수도있으니

Enum

Enum은 명명된 숫자 상수의 집합으로 열거형이라고 부른다. 자바스크립트는 enum을 지원하지 않지만 C자바 파이썬 등 여러 프로그래밍의 언어와 자바스크립트의 상위 확장인 타입스크립트에서는 enum을 지원한다.

자바스크립트에서 enum을 흉내 내어 사용하려면 객체변경 방지를 위한 object.freeze메서드와 심벌을 사용

심벌과 프로퍼티 키

심벌 값은 유일무이한 값이므로 심벌 값으로 프로퍼티 키를 만들면 다른프로퍼티 키 와 절대 충돌하지 않는다.

심벌과 프로퍼티 은닉

심벌값을 프로퍼티키로 사용하여 생성한 프로퍼티는 for...in 이나 object.keys 등의 메서드로 찾을 수 가없다.

하지만 완전하게 숨길수있는건아니다

Object.getOwnPropertySymbols 메서드를 사용하면 심벌 값을 프로퍼티 키로 사용하여 생성한 프로퍼티를 찾을 수 있다.

심벌과 표준 빌트인 객체 확장

일반적으로 표준 빌트인 객체에 사용자 정의 메서드를 직접 추가하여 확장하는 것은 권장하지 않는다.

표준 빌트인 객체는 읽기 전용으로 사용하는 것이 좋다.

이유는 개발자가 직접추가한 메서드와 미래에 표준 사양으로 추가될 메서드의 이름이 중복될 수 있기때문이다.

Well-known Symbol

자바스크립트가 기본 제공하는 빌트인 심벌 값이 있다. 빌트인 심벌 값은 Symbol 함수의 프로퍼티에 할당되어있다.

이걸 well-known Symbol 이라 부른다.

자바스크립트 내부 엔진의 내부 알고리즘에 사용된다 .

Array, map ,string …. 등등 for in으로 순회가능한 이터러블은 well`~~ symbol 인 symbol.interator를 키로 갖는 메서드를 가지며 이 메서드를 호출하여 반환하도록 규정되어있따.

이터레이션 프로포톸ㄹ을 준수한다.

이처럼 심벌은 중복되지않는 상수값을 생성하는 것은 물론 기존에 작성된 코드에 영향을 주지 않고 새로운 프로퍼티를 추가하기 위해 하위 호환성을 보장하기 위해 도입되었다.
