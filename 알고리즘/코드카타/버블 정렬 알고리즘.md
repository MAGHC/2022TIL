### 문제

### 버블정렬(Bubble Sort)

버블 정렬은 인접한 데이터를 교환해서 정렬하는 알고리즘입니다.
알고리즘의 정렬되는 모습이 마치 거품처럼 보인다고 해서 붙여진 이름입니다.

아래와 같은 정렬되지 않은 수가 있을 때, index 0 <-> 1 부터 교환하기 시작합니다.
인접한 두 수를 비교하여 더 큰 것을 우측으로 이동시킵니다.
**6 5** 3 2 8
-> **5 6** 3 2 8

그 다음은 index 1 <-> 2
5 **6 3** 2 8
-> 5 **3 6** 2 8

그 다음은 index 2 <-> 3
5 3 **6 2** 8
-> 5 3 **2 6** 8

그 다음은 index 3 <-> 4
5 3 2 **6 8**
-> 5 3 2 **6 8**
이렇게 제일 마지막 두 수 까지 비교하면, 제일 큰 수가 제일 마지막 index에 위치하는 것을 알 수 있습니다.

다시 처음부터 시작합니다.
**5 3** 2 6 8
-> **3 5** 2 6 8

3 **5 2** 6 8
-> 3 **2 5** 6 8

3 2 **5 6** 8
-> 3 2 **5 6** 8
이번 교환에는 index 2까지 비교하고 멈추면 됩니다.
마지막 index는 이미 제일 큰 수가 정렬된 상태이기 때문입니다.
이런식으로 계속 비교하고 교체하면 됩니다.!

# Problem

nums라는 배열을 주면, 버블정렬 알고리즘으로 배열을 정렬해주세요.

### 풀이

솔직히 말해서 처음 읽었을때 저번에 했던 선택정렬이랑 뭐가 다른거지? 했다

저번에 내기억에 선택정렬적으면서 sort 를 구현하는것이 아닌가 했는데 이게 sort에 더 가까운 방법인거같다.

이래놓고 내일 또 말 뒤집힐까봐 살짝 걱정되는데

선택정렬은 이중 포문에서
i랑 j 중 가장 작은 숫자를 찾아서 앞으로 옮기는거고

i =1 이면 j 는 전체를 도니까 그런식으로 하나씩 앞으로 바꾸는거고

이거는 a,b를 비교해서 바꾸는거다

결과적으로 정렬이라는건 똑같아서 뭔차인지 인지가 바로 안됬던것같다.

모양도 비슷함

```js
const bubbleSort = (nums) => {
  for (let i = 0; i < nums.length - 1; i++) {
    //마지막꺼는 비교할필요없음으로 - 이미 정렬됨
    for (let j = 0; j < nums.length - i; j++) {
      //a,b를 비교해야되니까 이번엔 j=i+1 이 아님 그리고 비교했으면 뒤에껀 재껴야되니까 length - i
      if (nums[j] > nums[j + 1]) {
        let temp = nums[j + 1];
        nums[j + 1] = nums[j];
        nums[j] = temp;
      }
    }
  }
  return nums;
  // 여기에 코드를 작성해주세요.
};

console.log(bubbleSort([42, 3, 41, 512, 421, 314, 5]));
```
